//
//  QuickDrawColor.swift
//  QuickDrawViewer
//
//  Created by Matthias Wiesmann on 27.02.2024.
//

import Foundation

typealias RGB8 = [UInt8];

func toRGB8(r: SIMD4<UInt8>, g: SIMD4<UInt8>, b: SIMD4<UInt8>) -> [RGB8] {
  return [
    [r.x, g.x, b.x], [r.y, g.y, b.y], [r.z, g.z, b.z], [r.w, g.w, b.w]];
}

/// Quickdraw stores RGB colours in 3 × 16 bit values.
/// Struct represents them as 64 bit value.
struct RGBColor : CustomStringConvertible, Hashable, RawRepresentable {
  
  let rawValue : UInt64;
  
  init(rawValue: UInt64)  {
    self.rawValue = rawValue & 0xffffffffffff;
  }
  
  init (red: UInt16, green: UInt16, blue: UInt16) {
    let r = UInt64(red);
    let g = UInt64(green);
    let b = UInt64(blue);
    self.init(rawValue: r << 32 | g << 16 | b);
  }
  
  init (red8: UInt8, green8: UInt8, blue8: UInt8) {
    let r = RGBColor.pad16(red8);
    let g = RGBColor.pad16(green8);
    let b = RGBColor.pad16(blue8);
    self.init(red: r, green: g, blue: b);
  }
  
  var red : UInt16 {
    return UInt16((rawValue >> 32) & 0xffff);
  }
  
  var green: UInt16 {
    return UInt16((rawValue >> 16) & 0xffff);
  }
  
  var blue: UInt16 {
    return UInt16(rawValue & 0xffff);
  }
  
  public var description: String {
    var result = "RGB: 0x";
    result += String(format: "%04X", red);
    result += "|";
    result += String(format: "%04X", green);
    result += "|";
    result += String(format: "%04X", green);
    return result;
  }
  
  /// Return classical 3 byte RGB representation.
  var rgb : RGB8 {
    var data : [UInt8] = [];
    data.append(UInt8(red >> 8));
    data.append(UInt8(green >> 8));
    data.append(UInt8(blue >> 8));
    return data;
  }
  
  // Convert a 8 bit color value into a 16 bit one.
  static func pad16<T : BinaryInteger>(_ value: T) -> UInt16 {
    return UInt16(value & 0xff) << 8 | UInt16(value & 0xff);
  }
    
  // Constants that represent the colours of QuickDraw 1.
  static let black = RGBColor(red8: 0x00, green8: 0x00, blue8: 0x00);
  static let white = RGBColor(red8: 0xff, green8: 0xff, blue8: 0xff);
  static let red = RGBColor(red8: 0xff, green8: 0x00, blue8: 0x00);
  static let green = RGBColor(red8: 0x00, green8: 0xff, blue8: 0x00);
  static let blue = RGBColor(red8: 0x00, green8: 0x00, blue8: 0xff);
  static let cyan = RGBColor(red8: 0x00, green8: 0xff, blue8: 0xff);
  static let magenta = RGBColor(red8: 0xff, green8: 0x00, blue8: 0xff);
  static let yellow = RGBColor(red8: 0xff, green8: 0xff, blue8: 0x00);
}

// CMYK color as a 64 bit quantity.
struct CMKYColor : RawRepresentable {
  init(rawValue : UInt64) {
    self.rawValue = rawValue;
  }
  
  init(cyan: UInt16, magenta: UInt16, yellow: UInt16, black : UInt16) {
    self.rawValue = 
        UInt64(cyan) << 48 |
        UInt64(magenta) << 32 |
        UInt64(yellow) << 16 |
    UInt64(black);
  }
  
  let rawValue : UInt64;
  
  var cyan: UInt16 {
    return UInt16((rawValue >> 48) & 0xffff);
  }
  var magenta: UInt16 {
    return UInt16((rawValue >> 32) & 0xffff);
  }
  var yellow: UInt16 {
    return UInt16((rawValue >> 16) & 0xffff);
  }
  var black: UInt16 {
    return UInt16((rawValue) & 0xffff);
  }
  
}

enum QD1Color : UInt32 {
  case black = 0x21;
  case white = 0x1e;
  case red = 0xcd;
  case blue = 0x199;
  case green = 0x155;
  case cyan = 0x111;
  case magenta = 0x89;
  case yellow = 0x45;
  
  var rgb : RGBColor {
    let r = UInt16(rawValue >> 5 & 0x01) * 0xFFFF;
    let g = UInt16(rawValue >> 4 & 0x01) * 0xFFFF;
    let b = UInt16(rawValue >> 3 & 0x01) * 0xFFFF;
    return RGBColor(red: r, green: g, blue: b);
  }
  
  var cmyk : CMKYColor {
    let c = UInt16(rawValue >> 9 & 0x01) * 0xFFFF;
    let m = UInt16(rawValue >> 8 & 0x01) * 0xFFFF;
    let y = UInt16(rawValue >> 7 & 0x01) * 0xFFFF;
    let k = UInt16(rawValue >> 6 & 0x01) * 0xFFFF;
    return CMKYColor(cyan: c, magenta: m, yellow: y, black: k);
  }
  
}

/// Pixel in ARGB555 format with the alpha in the first bit.
/// Mostly used by the RoadPizza decompressor.
struct ARGB555: RawRepresentable {
  
  init(rawValue: UInt16) {
    self.rawValue = rawValue
  }
  
  init(red: UInt8, green: UInt8, blue: UInt8) {
    rawValue = UInt16(blue & 0x1F) | UInt16(green & 0x1F) << 5 | UInt16(red & 0x1F) << 10 | 0x8000;
  }
  
  init(simd: SIMD3<UInt8>) {
    self.init(red: simd.x, green: simd.y, blue: simd.z);
  }
  
  var red : UInt8 {
    return UInt8((rawValue >> 10) & 0x1F);
  }
  
  var green : UInt8 {
    return UInt8((rawValue >> 5) & 0x1F);
  }
  
  var blue : UInt8 {
    return UInt8((rawValue) & 0x1F);
  }
  
  let rawValue : UInt16;
  
  var simdValue : SIMD3<UInt8> {
    return SIMD3<UInt8>(x: red, y: green, z:blue);
  }
  
  static let zero = ARGB555(rawValue: 0);
  static let pixelSize = 16;
  static let componentSize = 5;
}

enum QDColor : CustomStringConvertible {
  var description: String {
    switch self {
      case .rgb(let c):
        return c.description;
      case .qd1(let c):
        return "\(c)";
      case .cmyk(let c, let n):
        return "\(c) (\(String(describing: n))";
      case .blend(let a, let b, let w):
        return "\(a) / \(b) \(w)";
    }
  }
  
  case rgb(rgb: RGBColor);
  case qd1(qd1: QD1Color);
  case cmyk(cmyk: CMKYColor, name: String?);
  indirect case blend(colorA: QDColor, colorB: QDColor, weight: Double);

  static let black : QDColor = .rgb(rgb: RGBColor.black);
  static let white : QDColor = .rgb(rgb: RGBColor.white);
  
  func getRgb() throws  -> RGBColor {
    switch self {
      case .rgb(let rgb):
        return rgb;
      case .qd1(let qd1):
        return qd1.rgb;
      default:
        throw QuickDrawError.cannotConvertToRGB(color: self);
    }
  }
}

/// Standard Apple colour tables.
let clut1Raw : [UInt16] = [0x0000, 0x0001, 0x8000, 0x0001, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000 ];
let clut2Raw : [UInt16] = [0x0000, 0x0002, 0x8000, 0x0003, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xACAC, 0xACAC, 0xACAC, 0x0000, 0x5555, 0x5555, 0x5555, 0x0000, 0x0000, 0x0000, 0x0000];
let clut3Raw : [UInt16] = [0x0000, 0x007f, 0x8000, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFC00, 0xF37D, 0x052F, 0x0000, 0xF2D7, 0x0856, 0x84EC, 0x0000, 0xDD6B, 0x08C2, 0x06A2, 0x0000, 0x0241, 0xAB54, 0xEAFF, 0x0000, 0x0000, 0x8000, 0x11B0,0x0000,  0x0000, 0x0000, 0xD400, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF];
let clut4Raw : [UInt16] = [0x0000, 0x0004, 0x8000, 0x000F, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFC00, 0xF37D, 0x052F, 0x0000, 0xFFFF, 0x648A, 0x028C, 0x0000, 0xDD6B, 0x08C2, 0x06A2, 0x0000, 0xF2D7, 0x0856, 0x84EC, 0x0000, 0x46E3, 0x0000, 0xA53E, 0x0000, 0x0000, 0x0000, 0xD400, 0x0000, 0x0241, 0xAB54, 0xEAFF, 0x0000, 0x1F21, 0xB793, 0x1431, 0x0000, 0x0000, 0x64AF, 0x11B0, 0x0000, 0x5600, 0x2C9D, 0x0524, 0x0000, 0x90D7, 0x7160, 0x3A34, 0x0000, 0xC000, 0xC000, 0xC000, 0x0000, 0x8000, 0x8000, 0x8000, 0x0000, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000];
let clut8Raw : [UInt16] = [0x0000, 0x0008, 0x8000, 0x00FF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xCCCC, 0x0000, 0xFFFF, 0xFFFF, 0x9999, 0x0000, 0xFFFF, 0xFFFF, 0x6666, 0x0000, 0xFFFF, 0xFFFF, 0x3333, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xCCCC, 0xFFFF, 0x0000, 0xFFFF, 0xCCCC, 0xCCCC, 0x0000, 0xFFFF, 0xCCCC, 0x9999, 0x0000, 0xFFFF, 0xCCCC, 0x6666, 0x0000, 0xFFFF, 0xCCCC, 0x3333, 0x0000, 0xFFFF, 0xCCCC, 0x0000, 0x0000, 0xFFFF, 0x9999, 0xFFFF, 0x0000, 0xFFFF, 0x9999, 0xCCCC, 0x0000, 0xFFFF, 0x9999, 0x9999, 0x0000, 0xFFFF, 0x9999, 0x6666, 0x0000, 0xFFFF, 0x9999, 0x3333, 0x0000, 0xFFFF, 0x9999, 0x0000, 0x0000, 0xFFFF, 0x6666, 0xFFFF, 0x0000, 0xFFFF, 0x6666, 0xCCCC, 0x0000, 0xFFFF, 0x6666, 0x9999, 0x0000, 0xFFFF, 0x6666, 0x6666, 0x0000, 0xFFFF, 0x6666, 0x3333, 0x0000, 0xFFFF, 0x6666, 0x0000, 0x0000, 0xFFFF, 0x3333, 0xFFFF, 0x0000, 0xFFFF, 0x3333, 0xCCCC, 0x0000, 0xFFFF, 0x3333, 0x9999, 0x0000, 0xFFFF, 0x3333, 0x6666, 0x0000, 0xFFFF, 0x3333, 0x3333, 0x0000, 0xFFFF, 0x3333, 0x0000, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000, 0xCCCC, 0x0000, 0xFFFF, 0x0000, 0x9999, 0x0000, 0xFFFF, 0x0000, 0x6666, 0x0000, 0xFFFF, 0x0000, 0x3333, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xCCCC, 0xFFFF, 0xFFFF, 0x0000, 0xCCCC, 0xFFFF, 0xCCCC, 0x0000, 0xCCCC, 0xFFFF, 0x9999, 0x0000, 0xCCCC, 0xFFFF, 0x6666, 0x0000, 0xCCCC, 0xFFFF, 0x3333, 0x0000, 0xCCCC, 0xFFFF, 0x0000, 0x0000, 0xCCCC, 0xCCCC, 0xFFFF, 0x0000, 0xCCCC, 0xCCCC, 0xCCCC, 0x0000, 0xCCCC, 0xCCCC, 0x9999, 0x0000, 0xCCCC, 0xCCCC, 0x6666, 0x0000, 0xCCCC, 0xCCCC, 0x3333, 0x0000, 0xCCCC, 0xCCCC, 0x0000, 0x0000, 0xCCCC, 0x9999, 0xFFFF, 0x0000, 0xCCCC, 0x9999, 0xCCCC, 0x0000, 0xCCCC, 0x9999, 0x9999, 0x0000, 0xCCCC, 0x9999, 0x6666, 0x0000, 0xCCCC, 0x9999, 0x3333, 0x0000, 0xCCCC, 0x9999, 0x0000, 0x0000, 0xCCCC, 0x6666, 0xFFFF, 0x0000, 0xCCCC, 0x6666, 0xCCCC, 0x0000, 0xCCCC, 0x6666, 0x9999, 0x0000, 0xCCCC, 0x6666, 0x6666, 0x0000, 0xCCCC, 0x6666, 0x3333, 0x0000, 0xCCCC, 0x6666, 0x0000, 0x0000, 0xCCCC, 0x3333, 0xFFFF, 0x0000, 0xCCCC, 0x3333, 0xCCCC, 0x0000, 0xCCCC, 0x3333, 0x9999, 0x0000, 0xCCCC, 0x3333, 0x6666, 0x0000, 0xCCCC, 0x3333, 0x3333, 0x0000, 0xCCCC, 0x3333, 0x0000, 0x0000, 0xCCCC, 0x0000, 0xFFFF, 0x0000, 0xCCCC, 0x0000, 0xCCCC, 0x0000, 0xCCCC, 0x0000, 0x9999, 0x0000, 0xCCCC, 0x0000, 0x6666, 0x0000, 0xCCCC, 0x0000, 0x3333, 0x0000, 0xCCCC, 0x0000, 0x0000, 0x0000, 0x9999, 0xFFFF, 0xFFFF, 0x0000, 0x9999, 0xFFFF, 0xCCCC, 0x0000, 0x9999, 0xFFFF, 0x9999, 0x0000, 0x9999, 0xFFFF, 0x6666, 0x0000, 0x9999, 0xFFFF, 0x3333, 0x0000, 0x9999, 0xFFFF, 0x0000, 0x0000, 0x9999, 0xCCCC, 0xFFFF, 0x0000, 0x9999, 0xCCCC, 0xCCCC, 0x0000, 0x9999, 0xCCCC, 0x9999, 0x0000, 0x9999, 0xCCCC, 0x6666, 0x0000, 0x9999, 0xCCCC, 0x3333, 0x0000, 0x9999, 0xCCCC, 0x0000, 0x0000, 0x9999, 0x9999, 0xFFFF, 0x0000, 0x9999, 0x9999, 0xCCCC, 0x0000, 0x9999, 0x9999, 0x9999, 0x0000, 0x9999, 0x9999, 0x6666, 0x0000, 0x9999, 0x9999, 0x3333, 0x0000, 0x9999, 0x9999, 0x0000, 0x0000, 0x9999, 0x6666, 0xFFFF, 0x0000, 0x9999, 0x6666, 0xCCCC, 0x0000, 0x9999, 0x6666, 0x9999, 0x0000, 0x9999, 0x6666, 0x6666, 0x0000, 0x9999, 0x6666, 0x3333, 0x0000, 0x9999, 0x6666, 0x0000, 0x0000, 0x9999, 0x3333, 0xFFFF, 0x0000, 0x9999, 0x3333, 0xCCCC, 0x0000, 0x9999, 0x3333, 0x9999, 0x0000, 0x9999, 0x3333, 0x6666, 0x0000, 0x9999, 0x3333, 0x3333, 0x0000, 0x9999, 0x3333, 0x0000, 0x0000, 0x9999, 0x0000, 0xFFFF, 0x0000, 0x9999, 0x0000, 0xCCCC, 0x0000, 0x9999, 0x0000, 0x9999, 0x0000, 0x9999, 0x0000, 0x6666, 0x0000, 0x9999, 0x0000, 0x3333, 0x0000, 0x9999, 0x0000, 0x0000, 0x0000, 0x6666, 0xFFFF, 0xFFFF, 0x0000, 0x6666, 0xFFFF, 0xCCCC, 0x0000, 0x6666, 0xFFFF, 0x9999, 0x0000, 0x6666, 0xFFFF, 0x6666, 0x0000, 0x6666, 0xFFFF, 0x3333, 0x0000, 0x6666, 0xFFFF, 0x0000, 0x0000, 0x6666, 0xCCCC, 0xFFFF, 0x0000, 0x6666, 0xCCCC, 0xCCCC, 0x0000, 0x6666, 0xCCCC, 0x9999, 0x0000, 0x6666, 0xCCCC, 0x6666, 0x0000, 0x6666, 0xCCCC, 0x3333, 0x0000, 0x6666, 0xCCCC, 0x0000, 0x0000, 0x6666, 0x9999, 0xFFFF, 0x0000, 0x6666, 0x9999, 0xCCCC, 0x0000, 0x6666, 0x9999, 0x9999, 0x0000, 0x6666, 0x9999, 0x6666, 0x0000, 0x6666, 0x9999, 0x3333, 0x0000, 0x6666, 0x9999, 0x0000, 0x0000, 0x6666, 0x6666, 0xFFFF, 0x0000, 0x6666, 0x6666, 0xCCCC, 0x0000, 0x6666, 0x6666, 0x9999, 0x0000, 0x6666, 0x6666, 0x6666, 0x0000, 0x6666, 0x6666, 0x3333, 0x0000, 0x6666, 0x6666, 0x0000, 0x0000, 0x6666, 0x3333, 0xFFFF, 0x0000, 0x6666, 0x3333, 0xCCCC, 0x0000, 0x6666, 0x3333, 0x9999, 0x0000, 0x6666, 0x3333, 0x6666, 0x0000, 0x6666, 0x3333, 0x3333, 0x0000, 0x6666, 0x3333, 0x0000, 0x0000, 0x6666, 0x0000, 0xFFFF, 0x0000, 0x6666, 0x0000, 0xCCCC, 0x0000, 0x6666, 0x0000, 0x9999, 0x0000, 0x6666, 0x0000, 0x6666, 0x0000, 0x6666, 0x0000, 0x3333, 0x0000, 0x6666, 0x0000, 0x0000, 0x0000, 0x3333, 0xFFFF, 0xFFFF, 0x0000, 0x3333, 0xFFFF, 0xCCCC, 0x0000, 0x3333, 0xFFFF, 0x9999, 0x0000, 0x3333, 0xFFFF, 0x6666, 0x0000, 0x3333, 0xFFFF, 0x3333, 0x0000, 0x3333, 0xFFFF, 0x0000, 0x0000, 0x3333, 0xCCCC, 0xFFFF, 0x0000, 0x3333, 0xCCCC, 0xCCCC, 0x0000, 0x3333, 0xCCCC, 0x9999, 0x0000, 0x3333, 0xCCCC, 0x6666, 0x0000, 0x3333, 0xCCCC, 0x3333, 0x0000, 0x3333, 0xCCCC, 0x0000, 0x0000, 0x3333, 0x9999, 0xFFFF, 0x0000, 0x3333, 0x9999, 0xCCCC, 0x0000, 0x3333, 0x9999, 0x9999, 0x0000, 0x3333, 0x9999, 0x6666, 0x0000, 0x3333, 0x9999, 0x3333, 0x0000, 0x3333, 0x9999, 0x0000, 0x0000, 0x3333, 0x6666, 0xFFFF, 0x0000, 0x3333, 0x6666, 0xCCCC, 0x0000, 0x3333, 0x6666, 0x9999, 0x0000, 0x3333, 0x6666, 0x6666, 0x0000, 0x3333, 0x6666, 0x3333, 0x0000, 0x3333, 0x6666, 0x0000, 0x0000, 0x3333, 0x3333, 0xFFFF, 0x0000, 0x3333, 0x3333, 0xCCCC, 0x0000, 0x3333, 0x3333, 0x9999, 0x0000, 0x3333, 0x3333, 0x6666, 0x0000, 0x3333, 0x3333, 0x3333, 0x0000, 0x3333, 0x3333, 0x0000, 0x0000, 0x3333, 0x0000, 0xFFFF, 0x0000, 0x3333, 0x0000, 0xCCCC, 0x0000, 0x3333, 0x0000, 0x9999, 0x0000, 0x3333, 0x0000, 0x6666, 0x0000, 0x3333, 0x0000, 0x3333, 0x0000, 0x3333, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xCCCC, 0x0000, 0x0000, 0xFFFF, 0x9999, 0x0000, 0x0000, 0xFFFF, 0x6666, 0x0000, 0x0000, 0xFFFF, 0x3333, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xCCCC, 0xFFFF, 0x0000, 0x0000, 0xCCCC, 0xCCCC, 0x0000, 0x0000, 0xCCCC, 0x9999, 0x0000, 0x0000, 0xCCCC, 0x6666, 0x0000, 0x0000, 0xCCCC, 0x3333, 0x0000, 0x0000, 0xCCCC, 0x0000, 0x0000, 0x0000, 0x9999, 0xFFFF, 0x0000, 0x0000, 0x9999, 0xCCCC, 0x0000, 0x0000, 0x9999, 0x9999, 0x0000, 0x0000, 0x9999, 0x6666, 0x0000, 0x0000, 0x9999, 0x3333, 0x0000, 0x0000, 0x9999, 0x0000, 0x0000, 0x0000, 0x6666, 0xFFFF, 0x0000, 0x0000, 0x6666, 0xCCCC, 0x0000, 0x0000, 0x6666, 0x9999, 0x0000, 0x0000, 0x6666, 0x6666, 0x0000, 0x0000, 0x6666, 0x3333, 0x0000, 0x0000, 0x6666, 0x0000, 0x0000, 0x0000, 0x3333, 0xFFFF, 0x0000, 0x0000, 0x3333, 0xCCCC, 0x0000, 0x0000, 0x3333, 0x9999, 0x0000, 0x0000, 0x3333, 0x6666, 0x0000, 0x0000, 0x3333, 0x3333, 0x0000, 0x0000, 0x3333, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xCCCC, 0x0000, 0x0000, 0x0000, 0x9999, 0x0000, 0x0000, 0x0000, 0x6666, 0x0000, 0x0000, 0x0000, 0x3333, 0x0000, 0xEEEE, 0x0000, 0x0000, 0x0000, 0xDDDD, 0x0000, 0x0000, 0x0000, 0xBBBB, 0x0000, 0x0000, 0x0000, 0xAAAA, 0x0000, 0x0000, 0x0000, 0x8888, 0x0000, 0x0000, 0x0000, 0x7777, 0x0000, 0x0000, 0x0000, 0x5555, 0x0000, 0x0000, 0x0000, 0x4444, 0x0000, 0x0000, 0x0000, 0x2222, 0x0000, 0x0000, 0x0000, 0x1111, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE, 0x0000, 0x0000, 0x0000, 0xDDDD, 0x0000, 0x0000, 0x0000, 0xBBBB, 0x0000, 0x0000, 0x0000, 0xAAAA, 0x0000, 0x0000, 0x0000, 0x8888, 0x0000, 0x0000, 0x0000, 0x7777, 0x0000, 0x0000, 0x0000, 0x5555, 0x0000, 0x0000, 0x0000, 0x4444, 0x0000, 0x0000, 0x0000, 0x2222, 0x0000, 0x0000, 0x0000, 0x1111, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE, 0x0000, 0x0000, 0x0000, 0xDDDD, 0x0000, 0x0000, 0x0000, 0xBBBB, 0x0000, 0x0000, 0x0000, 0xAAAA, 0x0000, 0x0000, 0x0000, 0x8888, 0x0000, 0x0000, 0x0000, 0x7777, 0x0000, 0x0000, 0x0000, 0x5555, 0x0000, 0x0000, 0x0000, 0x4444, 0x0000, 0x0000, 0x0000, 0x2222, 0x0000, 0x0000, 0x0000, 0x1111, 0x0000, 0xEEEE, 0xEEEE, 0xEEEE, 0x0000, 0xDDDD, 0xDDDD, 0xDDDD, 0x0000, 0xBBBB, 0xBBBB, 0xBBBB, 0x0000, 0xAAAA, 0xAAAA, 0xAAAA, 0x0000, 0x8888, 0x8888, 0x8888, 0x0000, 0x7777, 0x7777, 0x7777, 0x0000, 0x5555, 0x5555, 0x5555, 0x0000, 0x4444, 0x4444, 0x4444, 0x0000, 0x2222, 0x2222, 0x2222, 0x0000, 0x1111, 0x1111, 0x1111, 0x0000, 0x0000, 0x0000, 0x0000 ];

/// Create a Color Table from it's raw value.
/// - Parameter raw: raw color table data as an array of UInt16
/// - Returns: a color table.
func clutFromRaw(raw: [UInt16]) -> QDColorTable {
  let id = Int(raw[1]);
  let clutFlags = raw[2];
  let size = raw[3];
  var p = 4;
  var clut : [RGBColor] = [];
  for _ in 0...size {
    let red = raw[p+1];
    let green = raw[p+2];
    let blue = raw[p+3];
    clut.append(RGBColor(red: red, green: green, blue: blue));
    p += 4;
  }
  return QDColorTable(clut: clut, id: id, clutFlags:clutFlags);
}

func clutFromRgb(rgb: [UInt8]) -> QDColorTable {
  var clut : [RGBColor] = [];
  for i in 0..<rgb.count / 3 {
    let p = i * 3;
    let color = RGBColor(red8: rgb[p], green8: rgb[p + 1], blue8: rgb[p + 2])
    clut.append(color);
  }
  return QDColorTable(clut: clut, id: 0, clutFlags:0);
}

func makeGrayRamp() -> QDColorTable {
  var clut : [RGBColor] = [];
  for v in 0..<0x100 {
    let luma = UInt8(v);
    clut.append(RGBColor(red8: luma, green8: luma, blue8: luma));
  }
  return QDColorTable(clut: clut, id: 0x28, clutFlags:0x8000);
}

/// ColorTable, typically called  `CLUT`.
class QDColorTable : CustomStringConvertible {
  public var description: String {
    let string_flag = String(format: "%0X ", clutFlags);
    var result = "flags: \(string_flag) "
    result += "clut \(clut.count) entries";
    return result;
  }
  
  init(clutFlags: UInt16) {
    self.clutFlags = clutFlags;
  }
  
  init(clut : [RGBColor], id: Int, clutFlags : UInt16) {
    self.id = id;
    self.clutFlags = clutFlags;
    self.clut = clut;
  }
  
  init(raw: [UInt32], id: Int) {
    self.id = id;
    self.clutFlags = 0;
    for v in raw {
      let r = RGBColor.pad16(v >> 16)
      let g = RGBColor.pad16(v >> 8);
      let b = RGBColor.pad16(v);
      let color = RGBColor(red: r, green: g, blue: b);
      clut.append(color)
    }
  }
  
  let clutFlags : UInt16;
  var clut : [RGBColor] = [];
  var id : Int = 0;
  
  func reversed(id: Int) -> QDColorTable {
    return QDColorTable(clut: self.clut.reversed(), id: id, clutFlags:0);
  }
  
  // Standard Apple color tables.
  static let palette1 = clutFromRaw(raw: clut1Raw);
  static let palette2 = clutFromRaw(raw: clut2Raw);
  static let palette3 = clutFromRaw(raw: clut3Raw)
  static let palette4 = clutFromRaw(raw: clut4Raw);
  static let palette8 = clutFromRaw(raw: clut8Raw);
  static let gray8 = makeGrayRamp();
  
  static func forClutId(clutId: Int) -> QDColorTable? {
    switch clutId {
    case 1: return palette1;
    case 2: return palette2;
    case 4: return palette4;
    case 8: return palette8;
    case 0x28: return gray8;
    case 0x7f: return palette3;
    default:
      return nil;
    }
  }
}



extension QuickDrawDataReader {
  func readRGB() throws -> RGBColor {
    let red = try readUInt16();
    let green = try readUInt16();
    let blue = try readUInt16();
    return RGBColor(red: red, green: green, blue: blue);
  }
  
  func readCMKY() throws -> CMKYColor {
    let raw = try readUInt64();
    return CMKYColor(rawValue: raw);
  }
  
  func ReadRGB555() throws -> ARGB555 {
    let raw = (try self.readUInt16()) | 0x8000;
    return ARGB555(rawValue: raw);
  }
  
  func readClut() throws -> QDColorTable {
    skip(bytes: 4);
    let clutFlags = try readUInt16();
    let colorTable = QDColorTable(clutFlags: clutFlags);
    let clutSize = try readUInt16();
    for index in 0...clutSize {
      let r_index = try readUInt16();
      // DeskDraw produces index with value 0x8000
      if r_index != index && r_index != 0x8000 {
        print("Inconsistent index: \(r_index)≠\(index)");
      }
      let color = try readRGB();
      colorTable.clut.append(color)
    }
    return colorTable;
  }
}
