//
//  QuickDrawColor.swift
//  QuickDrawViewer
//
//  Created by Matthias Wiesmann on 27.02.2024.
//

import Foundation

/// Quickdraw stores RGB colours in 3 × 16 bit values.
/// Struct represents them as 64 bit value.
struct RGBColor : CustomStringConvertible, Hashable, RawRepresentable {
  
  let rawValue : UInt64;
  
  init(rawValue: UInt64)  {
    self.rawValue = rawValue & 0xffffffffffff;
  }
  
  init(red: UInt16, green: UInt16, blue: UInt16) {
    let r = UInt64(red);
    let g = UInt64(green);
    let b = UInt64(blue);
    self.init(rawValue: r << 32 | g << 16 | b);
  }

  init(red8: UInt8, green8: UInt8, blue8: UInt8) {
    let r = padComponentTo16(red8);
    let g = padComponentTo16(green8);
    let b = padComponentTo16(blue8);
    self.init(red: r, green: g, blue: b);
  }

  var red : UInt16 {
    return UInt16((rawValue >> 32) & 0xffff);
  }
  
  var green: UInt16 {
    return UInt16((rawValue >> 16) & 0xffff);
  }
  
  var blue: UInt16 {
    return UInt16(rawValue & 0xffff);
  }
  
  public var description: String {
    var result = "RGB: 0x";
    result += String(format: "%04X", red);
    result += "|";
    result += String(format: "%04X", green);
    result += "|";
    result += String(format: "%04X", blue);
    return result;
  }
  
  /// Return classical 3 byte RGB representation.
  var rgb : RGB8 {
    return RGB8(r: UInt8(red >> 8), g: UInt8(green >> 8), b: UInt8(blue >> 8));
  }

  // Constants that represent the colours of QuickDraw 1.
  static let black = RGBColor(red8: 0x00, green8: 0x00, blue8: 0x00);
  static let white = RGBColor(red8: 0xff, green8: 0xff, blue8: 0xff);
  static let red = RGBColor(red8: 0xff, green8: 0x00, blue8: 0x00);
  static let green = RGBColor(red8: 0x00, green8: 0xff, blue8: 0x00);
  static let blue = RGBColor(red8: 0x00, green8: 0x00, blue8: 0xff);
  static let cyan = RGBColor(red8: 0x00, green8: 0xff, blue8: 0xff);
  static let magenta = RGBColor(red8: 0xff, green8: 0x00, blue8: 0xff);
  static let yellow = RGBColor(red8: 0xff, green8: 0xff, blue8: 0x00);
}

// CMYK color as a 64 bit quantity.
struct CMKYColor : RawRepresentable {
  init(rawValue : UInt64) {
    self.rawValue = rawValue;
  }
  
  init(cyan: UInt16, magenta: UInt16, yellow: UInt16, black : UInt16) {
    self.rawValue = 
        UInt64(cyan) << 48 |
        UInt64(magenta) << 32 |
        UInt64(yellow) << 16 |
    UInt64(black);
  }
  
  let rawValue : UInt64;
  
  var cyan: UInt16 {
    return UInt16((rawValue >> 48) & 0xffff);
  }
  var magenta: UInt16 {
    return UInt16((rawValue >> 32) & 0xffff);
  }
  var yellow: UInt16 {
    return UInt16((rawValue >> 16) & 0xffff);
  }
  var black: UInt16 {
    return UInt16((rawValue) & 0xffff);
  }
}

/// QuickDraw 1 color plane / plotter colours.
/// The 8 pre-defined colours are represented by their 1 bit representation
enum QD1Color : UInt32 {
  case black =   0b000100001;
  case white =   0b000011110;
  case red =     0b011001101;
  case blue =    0b110011001;
  case green =   0b101010101;
  case cyan =    0b100010001;
  case magenta = 0b010001001;
  case yellow =  0b001000101;

  var rgb : RGBColor {
    let r = UInt16(rawValue >> 5 & 0x01) * UInt16.max;
    let g = UInt16(rawValue >> 4 & 0x01) * UInt16.max;
    let b = UInt16(rawValue >> 3 & 0x01) * UInt16.max;
    return RGBColor(red: r, green: g, blue: b);
  }
  
  var cmyk : CMKYColor {
    let c = UInt16(rawValue >> 9 & 0x01) * UInt16.max;
    let m = UInt16(rawValue >> 8 & 0x01) * UInt16.max;
    let y = UInt16(rawValue >> 7 & 0x01) * UInt16.max;
    let k = UInt16(rawValue >> 6 & 0x01) * UInt16.max;
    return CMKYColor(cyan: c, magenta: m, yellow: y, black: k);
  }
  
}



enum QDColor : CustomStringConvertible {
  var description: String {
    switch self {
      case .rgb(let c):
        return c.description;
      case .qd1(let c):
        return "\(c)";
      case .cmyk(let c, let n):
        return "\(c) (\(String(describing: n))";
      case .blend(let a, let b, let w):
        return "\(a) / \(b) \(w)";
    }
  }
  
  case rgb(rgb: RGBColor);
  case qd1(qd1: QD1Color);
  case cmyk(cmyk: CMKYColor, name: String?);
  indirect case blend(colorA: QDColor, colorB: QDColor, weight: Double);

  static let black : QDColor = .rgb(rgb: RGBColor.black);
  static let white : QDColor = .rgb(rgb: RGBColor.white);
  
  func getRgb() throws  -> RGBColor {
    switch self {
      case .rgb(let rgb):
        return rgb;
      case .qd1(let qd1):
        return qd1.rgb;
      default:
        throw QuickDrawError.cannotConvertToRGB(color: self);
    }
  }
}

/// Standard Apple colour tables.
let clut1Raw : [UInt16] = [0x0000, 0x0001, 0x8000, 0x0001, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000 ];
let clut2Raw : [UInt16] = [0x0000, 0x0002, 0x8000, 0x0003, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xACAC, 0xACAC, 0xACAC, 0x0000, 0x5555, 0x5555, 0x5555, 0x0000, 0x0000, 0x0000, 0x0000];
let clut3Raw : [UInt16] = [0x0000, 0x007f, 0x8000, 0x0007, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFC00, 0xF37D, 0x052F, 0x0000, 0xF2D7, 0x0856, 0x84EC, 0x0000, 0xDD6B, 0x08C2, 0x06A2, 0x0000, 0x0241, 0xAB54, 0xEAFF, 0x0000, 0x0000, 0x8000, 0x11B0,0x0000,  0x0000, 0x0000, 0xD400, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF];
let clut4Raw : [UInt16] = [0x0000, 0x0004, 0x8000, 0x000F, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFC00, 0xF37D, 0x052F, 0x0000, 0xFFFF, 0x648A, 0x028C, 0x0000, 0xDD6B, 0x08C2, 0x06A2, 0x0000, 0xF2D7, 0x0856, 0x84EC, 0x0000, 0x46E3, 0x0000, 0xA53E, 0x0000, 0x0000, 0x0000, 0xD400, 0x0000, 0x0241, 0xAB54, 0xEAFF, 0x0000, 0x1F21, 0xB793, 0x1431, 0x0000, 0x0000, 0x64AF, 0x11B0, 0x0000, 0x5600, 0x2C9D, 0x0524, 0x0000, 0x90D7, 0x7160, 0x3A34, 0x0000, 0xC000, 0xC000, 0xC000, 0x0000, 0x8000, 0x8000, 0x8000, 0x0000, 0x4000, 0x4000, 0x4000, 0x0000, 0x0000, 0x0000, 0x0000];
let clut8Raw : [UInt16] = [0x0000, 0x0008, 0x8000, 0x00FF, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000, 0xFFFF, 0xFFFF, 0xCCCC, 0x0000, 0xFFFF, 0xFFFF, 0x9999, 0x0000, 0xFFFF, 0xFFFF, 0x6666, 0x0000, 0xFFFF, 0xFFFF, 0x3333, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xCCCC, 0xFFFF, 0x0000, 0xFFFF, 0xCCCC, 0xCCCC, 0x0000, 0xFFFF, 0xCCCC, 0x9999, 0x0000, 0xFFFF, 0xCCCC, 0x6666, 0x0000, 0xFFFF, 0xCCCC, 0x3333, 0x0000, 0xFFFF, 0xCCCC, 0x0000, 0x0000, 0xFFFF, 0x9999, 0xFFFF, 0x0000, 0xFFFF, 0x9999, 0xCCCC, 0x0000, 0xFFFF, 0x9999, 0x9999, 0x0000, 0xFFFF, 0x9999, 0x6666, 0x0000, 0xFFFF, 0x9999, 0x3333, 0x0000, 0xFFFF, 0x9999, 0x0000, 0x0000, 0xFFFF, 0x6666, 0xFFFF, 0x0000, 0xFFFF, 0x6666, 0xCCCC, 0x0000, 0xFFFF, 0x6666, 0x9999, 0x0000, 0xFFFF, 0x6666, 0x6666, 0x0000, 0xFFFF, 0x6666, 0x3333, 0x0000, 0xFFFF, 0x6666, 0x0000, 0x0000, 0xFFFF, 0x3333, 0xFFFF, 0x0000, 0xFFFF, 0x3333, 0xCCCC, 0x0000, 0xFFFF, 0x3333, 0x9999, 0x0000, 0xFFFF, 0x3333, 0x6666, 0x0000, 0xFFFF, 0x3333, 0x3333, 0x0000, 0xFFFF, 0x3333, 0x0000, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000, 0xFFFF, 0x0000, 0xCCCC, 0x0000, 0xFFFF, 0x0000, 0x9999, 0x0000, 0xFFFF, 0x0000, 0x6666, 0x0000, 0xFFFF, 0x0000, 0x3333, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xCCCC, 0xFFFF, 0xFFFF, 0x0000, 0xCCCC, 0xFFFF, 0xCCCC, 0x0000, 0xCCCC, 0xFFFF, 0x9999, 0x0000, 0xCCCC, 0xFFFF, 0x6666, 0x0000, 0xCCCC, 0xFFFF, 0x3333, 0x0000, 0xCCCC, 0xFFFF, 0x0000, 0x0000, 0xCCCC, 0xCCCC, 0xFFFF, 0x0000, 0xCCCC, 0xCCCC, 0xCCCC, 0x0000, 0xCCCC, 0xCCCC, 0x9999, 0x0000, 0xCCCC, 0xCCCC, 0x6666, 0x0000, 0xCCCC, 0xCCCC, 0x3333, 0x0000, 0xCCCC, 0xCCCC, 0x0000, 0x0000, 0xCCCC, 0x9999, 0xFFFF, 0x0000, 0xCCCC, 0x9999, 0xCCCC, 0x0000, 0xCCCC, 0x9999, 0x9999, 0x0000, 0xCCCC, 0x9999, 0x6666, 0x0000, 0xCCCC, 0x9999, 0x3333, 0x0000, 0xCCCC, 0x9999, 0x0000, 0x0000, 0xCCCC, 0x6666, 0xFFFF, 0x0000, 0xCCCC, 0x6666, 0xCCCC, 0x0000, 0xCCCC, 0x6666, 0x9999, 0x0000, 0xCCCC, 0x6666, 0x6666, 0x0000, 0xCCCC, 0x6666, 0x3333, 0x0000, 0xCCCC, 0x6666, 0x0000, 0x0000, 0xCCCC, 0x3333, 0xFFFF, 0x0000, 0xCCCC, 0x3333, 0xCCCC, 0x0000, 0xCCCC, 0x3333, 0x9999, 0x0000, 0xCCCC, 0x3333, 0x6666, 0x0000, 0xCCCC, 0x3333, 0x3333, 0x0000, 0xCCCC, 0x3333, 0x0000, 0x0000, 0xCCCC, 0x0000, 0xFFFF, 0x0000, 0xCCCC, 0x0000, 0xCCCC, 0x0000, 0xCCCC, 0x0000, 0x9999, 0x0000, 0xCCCC, 0x0000, 0x6666, 0x0000, 0xCCCC, 0x0000, 0x3333, 0x0000, 0xCCCC, 0x0000, 0x0000, 0x0000, 0x9999, 0xFFFF, 0xFFFF, 0x0000, 0x9999, 0xFFFF, 0xCCCC, 0x0000, 0x9999, 0xFFFF, 0x9999, 0x0000, 0x9999, 0xFFFF, 0x6666, 0x0000, 0x9999, 0xFFFF, 0x3333, 0x0000, 0x9999, 0xFFFF, 0x0000, 0x0000, 0x9999, 0xCCCC, 0xFFFF, 0x0000, 0x9999, 0xCCCC, 0xCCCC, 0x0000, 0x9999, 0xCCCC, 0x9999, 0x0000, 0x9999, 0xCCCC, 0x6666, 0x0000, 0x9999, 0xCCCC, 0x3333, 0x0000, 0x9999, 0xCCCC, 0x0000, 0x0000, 0x9999, 0x9999, 0xFFFF, 0x0000, 0x9999, 0x9999, 0xCCCC, 0x0000, 0x9999, 0x9999, 0x9999, 0x0000, 0x9999, 0x9999, 0x6666, 0x0000, 0x9999, 0x9999, 0x3333, 0x0000, 0x9999, 0x9999, 0x0000, 0x0000, 0x9999, 0x6666, 0xFFFF, 0x0000, 0x9999, 0x6666, 0xCCCC, 0x0000, 0x9999, 0x6666, 0x9999, 0x0000, 0x9999, 0x6666, 0x6666, 0x0000, 0x9999, 0x6666, 0x3333, 0x0000, 0x9999, 0x6666, 0x0000, 0x0000, 0x9999, 0x3333, 0xFFFF, 0x0000, 0x9999, 0x3333, 0xCCCC, 0x0000, 0x9999, 0x3333, 0x9999, 0x0000, 0x9999, 0x3333, 0x6666, 0x0000, 0x9999, 0x3333, 0x3333, 0x0000, 0x9999, 0x3333, 0x0000, 0x0000, 0x9999, 0x0000, 0xFFFF, 0x0000, 0x9999, 0x0000, 0xCCCC, 0x0000, 0x9999, 0x0000, 0x9999, 0x0000, 0x9999, 0x0000, 0x6666, 0x0000, 0x9999, 0x0000, 0x3333, 0x0000, 0x9999, 0x0000, 0x0000, 0x0000, 0x6666, 0xFFFF, 0xFFFF, 0x0000, 0x6666, 0xFFFF, 0xCCCC, 0x0000, 0x6666, 0xFFFF, 0x9999, 0x0000, 0x6666, 0xFFFF, 0x6666, 0x0000, 0x6666, 0xFFFF, 0x3333, 0x0000, 0x6666, 0xFFFF, 0x0000, 0x0000, 0x6666, 0xCCCC, 0xFFFF, 0x0000, 0x6666, 0xCCCC, 0xCCCC, 0x0000, 0x6666, 0xCCCC, 0x9999, 0x0000, 0x6666, 0xCCCC, 0x6666, 0x0000, 0x6666, 0xCCCC, 0x3333, 0x0000, 0x6666, 0xCCCC, 0x0000, 0x0000, 0x6666, 0x9999, 0xFFFF, 0x0000, 0x6666, 0x9999, 0xCCCC, 0x0000, 0x6666, 0x9999, 0x9999, 0x0000, 0x6666, 0x9999, 0x6666, 0x0000, 0x6666, 0x9999, 0x3333, 0x0000, 0x6666, 0x9999, 0x0000, 0x0000, 0x6666, 0x6666, 0xFFFF, 0x0000, 0x6666, 0x6666, 0xCCCC, 0x0000, 0x6666, 0x6666, 0x9999, 0x0000, 0x6666, 0x6666, 0x6666, 0x0000, 0x6666, 0x6666, 0x3333, 0x0000, 0x6666, 0x6666, 0x0000, 0x0000, 0x6666, 0x3333, 0xFFFF, 0x0000, 0x6666, 0x3333, 0xCCCC, 0x0000, 0x6666, 0x3333, 0x9999, 0x0000, 0x6666, 0x3333, 0x6666, 0x0000, 0x6666, 0x3333, 0x3333, 0x0000, 0x6666, 0x3333, 0x0000, 0x0000, 0x6666, 0x0000, 0xFFFF, 0x0000, 0x6666, 0x0000, 0xCCCC, 0x0000, 0x6666, 0x0000, 0x9999, 0x0000, 0x6666, 0x0000, 0x6666, 0x0000, 0x6666, 0x0000, 0x3333, 0x0000, 0x6666, 0x0000, 0x0000, 0x0000, 0x3333, 0xFFFF, 0xFFFF, 0x0000, 0x3333, 0xFFFF, 0xCCCC, 0x0000, 0x3333, 0xFFFF, 0x9999, 0x0000, 0x3333, 0xFFFF, 0x6666, 0x0000, 0x3333, 0xFFFF, 0x3333, 0x0000, 0x3333, 0xFFFF, 0x0000, 0x0000, 0x3333, 0xCCCC, 0xFFFF, 0x0000, 0x3333, 0xCCCC, 0xCCCC, 0x0000, 0x3333, 0xCCCC, 0x9999, 0x0000, 0x3333, 0xCCCC, 0x6666, 0x0000, 0x3333, 0xCCCC, 0x3333, 0x0000, 0x3333, 0xCCCC, 0x0000, 0x0000, 0x3333, 0x9999, 0xFFFF, 0x0000, 0x3333, 0x9999, 0xCCCC, 0x0000, 0x3333, 0x9999, 0x9999, 0x0000, 0x3333, 0x9999, 0x6666, 0x0000, 0x3333, 0x9999, 0x3333, 0x0000, 0x3333, 0x9999, 0x0000, 0x0000, 0x3333, 0x6666, 0xFFFF, 0x0000, 0x3333, 0x6666, 0xCCCC, 0x0000, 0x3333, 0x6666, 0x9999, 0x0000, 0x3333, 0x6666, 0x6666, 0x0000, 0x3333, 0x6666, 0x3333, 0x0000, 0x3333, 0x6666, 0x0000, 0x0000, 0x3333, 0x3333, 0xFFFF, 0x0000, 0x3333, 0x3333, 0xCCCC, 0x0000, 0x3333, 0x3333, 0x9999, 0x0000, 0x3333, 0x3333, 0x6666, 0x0000, 0x3333, 0x3333, 0x3333, 0x0000, 0x3333, 0x3333, 0x0000, 0x0000, 0x3333, 0x0000, 0xFFFF, 0x0000, 0x3333, 0x0000, 0xCCCC, 0x0000, 0x3333, 0x0000, 0x9999, 0x0000, 0x3333, 0x0000, 0x6666, 0x0000, 0x3333, 0x0000, 0x3333, 0x0000, 0x3333, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0xCCCC, 0x0000, 0x0000, 0xFFFF, 0x9999, 0x0000, 0x0000, 0xFFFF, 0x6666, 0x0000, 0x0000, 0xFFFF, 0x3333, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xCCCC, 0xFFFF, 0x0000, 0x0000, 0xCCCC, 0xCCCC, 0x0000, 0x0000, 0xCCCC, 0x9999, 0x0000, 0x0000, 0xCCCC, 0x6666, 0x0000, 0x0000, 0xCCCC, 0x3333, 0x0000, 0x0000, 0xCCCC, 0x0000, 0x0000, 0x0000, 0x9999, 0xFFFF, 0x0000, 0x0000, 0x9999, 0xCCCC, 0x0000, 0x0000, 0x9999, 0x9999, 0x0000, 0x0000, 0x9999, 0x6666, 0x0000, 0x0000, 0x9999, 0x3333, 0x0000, 0x0000, 0x9999, 0x0000, 0x0000, 0x0000, 0x6666, 0xFFFF, 0x0000, 0x0000, 0x6666, 0xCCCC, 0x0000, 0x0000, 0x6666, 0x9999, 0x0000, 0x0000, 0x6666, 0x6666, 0x0000, 0x0000, 0x6666, 0x3333, 0x0000, 0x0000, 0x6666, 0x0000, 0x0000, 0x0000, 0x3333, 0xFFFF, 0x0000, 0x0000, 0x3333, 0xCCCC, 0x0000, 0x0000, 0x3333, 0x9999, 0x0000, 0x0000, 0x3333, 0x6666, 0x0000, 0x0000, 0x3333, 0x3333, 0x0000, 0x0000, 0x3333, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0xCCCC, 0x0000, 0x0000, 0x0000, 0x9999, 0x0000, 0x0000, 0x0000, 0x6666, 0x0000, 0x0000, 0x0000, 0x3333, 0x0000, 0xEEEE, 0x0000, 0x0000, 0x0000, 0xDDDD, 0x0000, 0x0000, 0x0000, 0xBBBB, 0x0000, 0x0000, 0x0000, 0xAAAA, 0x0000, 0x0000, 0x0000, 0x8888, 0x0000, 0x0000, 0x0000, 0x7777, 0x0000, 0x0000, 0x0000, 0x5555, 0x0000, 0x0000, 0x0000, 0x4444, 0x0000, 0x0000, 0x0000, 0x2222, 0x0000, 0x0000, 0x0000, 0x1111, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE, 0x0000, 0x0000, 0x0000, 0xDDDD, 0x0000, 0x0000, 0x0000, 0xBBBB, 0x0000, 0x0000, 0x0000, 0xAAAA, 0x0000, 0x0000, 0x0000, 0x8888, 0x0000, 0x0000, 0x0000, 0x7777, 0x0000, 0x0000, 0x0000, 0x5555, 0x0000, 0x0000, 0x0000, 0x4444, 0x0000, 0x0000, 0x0000, 0x2222, 0x0000, 0x0000, 0x0000, 0x1111, 0x0000, 0x0000, 0x0000, 0x0000, 0xEEEE, 0x0000, 0x0000, 0x0000, 0xDDDD, 0x0000, 0x0000, 0x0000, 0xBBBB, 0x0000, 0x0000, 0x0000, 0xAAAA, 0x0000, 0x0000, 0x0000, 0x8888, 0x0000, 0x0000, 0x0000, 0x7777, 0x0000, 0x0000, 0x0000, 0x5555, 0x0000, 0x0000, 0x0000, 0x4444, 0x0000, 0x0000, 0x0000, 0x2222, 0x0000, 0x0000, 0x0000, 0x1111, 0x0000, 0xEEEE, 0xEEEE, 0xEEEE, 0x0000, 0xDDDD, 0xDDDD, 0xDDDD, 0x0000, 0xBBBB, 0xBBBB, 0xBBBB, 0x0000, 0xAAAA, 0xAAAA, 0xAAAA, 0x0000, 0x8888, 0x8888, 0x8888, 0x0000, 0x7777, 0x7777, 0x7777, 0x0000, 0x5555, 0x5555, 0x5555, 0x0000, 0x4444, 0x4444, 0x4444, 0x0000, 0x2222, 0x2222, 0x2222, 0x0000, 0x1111, 0x1111, 0x1111, 0x0000, 0x0000, 0x0000, 0x0000 ];

/// Create a Color Table from it's raw value.
/// - Parameter raw: raw color table data as an array of UInt16
/// - Returns: a color table.
func clutFromRaw(raw: [UInt16]) -> QDColorTable {
  let id = Int(raw[1]);
  let clutFlags = raw[2];
  let size = raw[3];
  var p = 4;
  var clut : [RGBColor] = [];
  for _ in 0...size {
    let red = raw[p+1];
    let green = raw[p+2];
    let blue = raw[p+3];
    clut.append(RGBColor(red: red, green: green, blue: blue));
    p += 4;
  }
  return QDColorTable(clut: clut, id: id, clutFlags:clutFlags);
}

func clutFromRgb(rgb: [UInt8]) -> QDColorTable {
  var clut : [RGBColor] = [];
  for i in 0..<rgb.count / 3 {
    let p = i * 3;
    let color = RGBColor(red8: rgb[p], green8: rgb[p + 1], blue8: rgb[p + 2])
    clut.append(color);
  }
  return QDColorTable(clut: clut, id: 0, clutFlags:0);
}

func makeGrayRamp() -> QDColorTable {
  var clut : [RGBColor] = [];
  for v in 0..<0x100 {
    let luma = UInt8(v);
    clut.append(RGBColor(red8: luma, green8: luma, blue8: luma));
  }
  return QDColorTable(clut: clut, id: 0x28, clutFlags:0x8000);
}

/// ColorTable, typically called  `CLUT`.
final class QDColorTable : CustomStringConvertible, Sendable {
  public var description: String {
    let string_flag = String(format: "%0X ", clutFlags);
    var result = "CLUT \(id) [flags: \(string_flag)"
    result += " \(clut.count) entries";
    result += "]";
    return result;
  }

  init(clut : [RGBColor], id: Int, clutFlags : UInt16) {
    self.id = id;
    self.clutFlags = clutFlags;
    self.clut = clut;
  }
  
  init(raw: [UInt32], id: Int) {
    self.id = id;
    self.clutFlags = 0;
    var clut : [RGBColor] = [];
    for v in raw {
      let r = padComponentTo16(v >> 16)
      let g = padComponentTo16(v >> 8);
      let b = padComponentTo16(v);
      let color = RGBColor(red: r, green: g, blue: b);
      clut.append(color)
    }
    self.clut = clut;
  }
  
  let clutFlags : UInt16;
  let clut : [RGBColor];
  let id : Int;

  func reversed(id: Int) -> QDColorTable {
    return QDColorTable(clut: self.clut.reversed(), id: id, clutFlags:0);
  }
  
  // Standard Apple color tables.
  static let palette1 = clutFromRaw(raw: clut1Raw);
  static let palette2 = clutFromRaw(raw: clut2Raw);
  static let palette3 = clutFromRaw(raw: clut3Raw)
  static let palette4 = clutFromRaw(raw: clut4Raw);
  static let palette8 = clutFromRaw(raw: clut8Raw);
  static let gray8 = makeGrayRamp();
  
  static func forClutId(clutId: Int) -> QDColorTable? {
    switch clutId {
    case 1: return palette1;
    case 2: return palette2;
    case 4: return palette4;
    case 8: return palette8;
    case 0x28: return gray8;
    case 0x7f: return palette3;
    default:
      return nil;
    }
  }
}

extension QuickDrawDataReader {
  func readRGB() throws -> RGBColor {
    let red = try readUInt16();
    let green = try readUInt16();
    let blue = try readUInt16();
    return RGBColor(red: red, green: green, blue: blue);
  }
  
  func readCMKY() throws -> CMKYColor {
    let raw = try readUInt64();
    return CMKYColor(rawValue: raw);
  }
  
  func ReadRGB555() throws -> ARGB555 {
    let raw = (try self.readUInt16()) | 0x8000;
    return ARGB555(rawValue: raw);
  }
  
  func readQD1Color() throws -> QD1Color {
    let code = try readUInt32();
    guard let qd1 = QD1Color(rawValue: code) else {
      throw QuickDrawError.unsupportedQD1Color(colorCode: code);
    }
    return qd1;
  }
  
  func readClut() throws -> QDColorTable {
    skip(bytes: 4);
    let clutFlags = try readUInt16();
    let clutSize = try readUInt16();
    var clut : [RGBColor] = [];

    for index in 0...clutSize {
      let r_index = try readUInt16();
      // DeskDraw produces index with value 0x8000
      if r_index != index && r_index != 0x8000 {
        print("Inconsistent index: \(r_index)≠\(index)");
      }
      let color = try readRGB();
      clut.append(color);
    }
    return QDColorTable(clut: clut, id: 0,  clutFlags: clutFlags);
  }
}

enum GradientType {
  case linear(angleDegrees: Int);
  case radial;
}

struct GradientDescription {
  let type : GradientType;
  let colors : [QDColor];
}
